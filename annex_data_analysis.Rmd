---
title: "Annex - Data analysis"
author: "Maria Mercedes Serra"
date: "4/29/2022"
output: 
  html_document:
      toc: yes
      toc_float: yes
      toc_depth: 5
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE,
                      message = FALSE,
                      error=TRUE)
```


I load the required packages for current analysis.


```{r}
require(pacman)
p_load(dlookr,patchwork,skimr,kableExtra,naniar,lubridate,purrr,tidyr,
       crosstable,flextable,scales,survival,survminer,DataExplorer,performance,
       missForest,HDoutliers,caret,praznik,mRMRe,VarSelLCM,cluster,plotly,
       ca,factoextra, tidyverse)
```



## Data


```{r}
# I load the data from csv file:
lung_data <- read.csv('data/complete_clinrad_data.csv', sep = ',') # called complete clin rad data

# I assign Patient ID to rownames to ease further work with the data
rownames(lung_data) <- lung_data$PatientID

#I remove PatientID column an additional index column not of interest as we will use rownames(patient id) to identify each entry
lung_data <- lung_data %>% select(.,-c(X,PatientID))

# I check dataframe dimensions:
dim(lung_data)

# As many clinical variables are identified as numeric when this is not the case, 
# I modify data type for specific variables of interest
# clinical T,N,M and overall stage are ordered categorical variables:
lung_data$clinical.T.Stage <- factor(lung_data$clinical.T.Stage, ordered = TRUE)
lung_data$Clinical.N.Stage <- factor(lung_data$Clinical.N.Stage, ordered = TRUE)
lung_data$Clinical.M.Stage <- factor(lung_data$Clinical.M.Stage, ordered = TRUE)
lung_data$Overall.Stage <- factor(lung_data$Overall.Stage, ordered = TRUE)

# dead status event is a binary categorical variable:
lung_data$deadstatus.event <- factor(lung_data$deadstatus.event)

# gender, histology, and manufacturer are all categorical variables also:
lung_data$gender <- factor(lung_data$gender)
lung_data$Histology <- factor(lung_data$Histology)
lung_data$Manufacturer <- factor(lung_data$Manufacturer)

# study date is a date variable, we adjust format with the help of lubridate package:
lung_data$Study.Date <- mdy(lung_data$Study.Date)

# I check resulting data structure and varnames for the modified variables:
str(lung_data[1:11])

# We can see the remaining numeric variables account for all the radiomic variables (1246)
dim(lung_data %>% keep(is.numeric) %>% select(.,-c(age,Survival.time)))
```



## Initial exploratory analysis


### Search for missing values


First I do an exploratory analysis to check for missing values in the whole data frame.


```{r}
table(is.na(lung_data))
table(is.null(lung_data))
```


We can see there are 66 missing values in total.


I generate a table that shows within the whole dataframe the variables with a list one missing value and the detail of number of missing values and its completeness rate.


```{r}
(table1 <- skim(lung_data) %>% 
   select(skim_variable,n_missing,complete_rate) %>% 
   filter(n_missing > 0) %>% 
   kable(full_with = FALSE) %>% 
   kable_classic_2()) 
table1 %>% save_kable("tables/table1.pdf")
```



I generate visual representations of single and joint missing values using `gg_miss_upset` function from `naniar` package.


```{r}
tiff(filename = "figures/Fig1.tiff", width = 200, height = 150, units = "mm", res = 300)
gg_miss_upset(lung_data %>% select_if(~ any(is.na(.)))) 
fig <- dev.off()
gg_miss_upset(lung_data %>% select_if(~ any(is.na(.))))
```


Overall completeness rate was superior to 0.9 for every variable. Histology is our response variable for our first research question so observations without a value for histology variable will be fully excluded. In addition as a subgroup of NSCLC not otherwise specified (nos) is available within the histology categories it is not clear if NA cases have in effect the confirmation of NSCLC diagnosis at all; so it makes sense to exclude this cases.



```{r}
lung_data_complete <- lung_data %>% drop_na(Histology)
dim(lung_data_complete)
```


After excluding every row with missing histology value, we end up with 379 observations.
On the contrary we might imput missing values affecting other variables to avoid missing additional observations that may be usefull, but I will continue with imputation after evaluation data distribution,  and data coherence to check if any additional values should be considered as missing and which imputation technique might be pertinent to use.



### Identify distribution of the different variables and check coherence 


I verify general statistical summary and distribution of features.


First for study dates:


```{r}
lung_data_complete %>% select(Study.Date) %>% skim()
```


Then I get summary statistics for factor variables:


```{r}
(table2a <- lung_data_complete %>% 
    select(Histology,gender,deadstatus.event,Manufacturer) %>% 
    univar_category() %>% 
    kable(full_with = FALSE) %>% kable_classic())
table2a %>% save_kable("tables/table2a.pdf")
(table2b <- lung_data_complete %>% 
    select(Overall.Stage,clinical.T.Stage,Clinical.N.Stage,Clinical.M.Stage) %>% 
    univar_category() %>% 
    kable(full_with = FALSE) %>% kable_classic())
table2b %>% save_kable("tables/table2b.pdf")
```


I represent factor variables with barplots to visualize data distribution and clases available for each categorical variable:


```{r, fig.height=10, fig.width=8}
lung_data_complete %>%
  keep(is.factor) %>% 
  gather() %>% 
  ggplot(aes(value)) +
    facet_wrap(~ key, scales = "free",ncol = 2) +
    geom_bar()+
    scale_y_continuous( limits = c(0,400)) +
    geom_text(stat='count', aes(label=..count..), vjust=-0.1, size = 7) +
    theme(strip.text.x = element_text(size = 18), text = element_text(size=19))
ggsave("figures/Fig2.tiff", scale = 0.4)
```


We can see from the Overall.Stage variable distribution, that stage IV is not represented in this dataset so we will center analysis mainly on this groups of non-metastatic disease patients. There seems to be some isolated incoherent, erroneous registries regarding clinical T, N and M categories. Possible values for clinical.T.Stage category in lung cancer range from T1 to T4, and as we can see there are few cases with T == 5. Same happens with Clinical.N.Stage == 4 and we also find some cases with Clinical M Stage == 3 that do not exists either within this classicifcation. Specific incoherent cases are enumerated in tables 5.3, 5.4, 5.5 respectively.



```{r}
(table3 <- lung_data_complete %>% 
  filter(clinical.T.Stage ==5) %>% select(clinical.T.Stage,Overall.Stage)  %>% 
  kable(full_with = FALSE) %>% 
  kable_classic_2())
table3 %>% save_kable("tables/table3.pdf")
```


```{r}
(table4 <- lung_data_complete %>% 
  filter(Clinical.N.Stage ==4) %>% select(Clinical.N.Stage,Overall.Stage) %>% 
  kable(full_with = FALSE) %>% 
  kable_classic_2())
table4 %>% save_kable("tables/table4.pdf")
```



```{r}
(table5 <- lung_data_complete %>% filter(Clinical.M.Stage ==3) %>% 
  select(Clinical.M.Stage,Overall.Stage) %>% 
  kable(full_with = FALSE) %>% 
  kable_classic_2()) 
table5 %>% save_kable("tables/table5.pdf")
```



These are interpreted as erroneous so missing values are assigned to replace these entries as well as for plastimatch manufacturer. This will be then handled along with missing values imputation.


```{r}
# I assign na values to erroneous entries and drop unused levels:
lung_data_complete <- lung_data_complete %>% replace_with_na(
  replace = list(clinical.T.Stage = 5,
                 Clinical.N.Stage = 4,
                 Clinical.M.Stage = 3,
                 Manufacturer = 'Plastimatch')) %>%
  droplevels.data.frame()
```



We can see now the joint missing patterns after removing observations with histology missing values and imputing with missing values the incoherent clinical T/N/M entries:


```{r}
tiff(filename = "figures/Fig3.tiff", width = 200, height = 150, units = "mm", res = 300)
gg_miss_upset(lung_data_complete %>% select_if(~ any(is.na(.)))) 
fig <- dev.off()
gg_miss_upset(lung_data_complete %>% select_if(~ any(is.na(.))))
```



Now I continue with the summary statistics for numeric clinical numeric variables: 


```{r}
(table6 <- lung_data_complete %>% 
  select(age,Survival.time) %>% 
  describe() %>%
  select(described_variables,n,na,mean,sd,se_mean,IQR,skewness,kurtosis) %>% 
  kable(full_with = FALSE) %>% kable_classic_2()) 
table6 %>% save_kable("tables/table6.pdf")
```


And generate histograms to better visualize distributions:


- First for the remaining clinical variables:


```{r}
g1 <- ggplot(lung_data_complete,aes(age)) + 
  geom_histogram(alpha = .8) +
  theme_bw() 
g2 <- ggplot(lung_data_complete,aes(Survival.time)) + 
  geom_histogram(alpha = .8) +
  theme_bw()
(g1 + g2)
ggsave("figures/Fig4.tiff",width = 174, height = 100, device="tiff", dpi=300, units = "mm", scale = 1)
```


- As we have 1246 radiomic variables, I'll continue exploring clinical and main study info first, and continue with radiomics exploratory analysis while and after performing variable selection



### Check relationship/independency between different type of variables


First as my first research question is weather radiomic variables are related with histology class or not, I want to check histology is independent from other clinical variables and manufacturer of the scanner used to do the exam. 



```{r}
g1 <- ggplot(lung_data_complete,aes(age, fill = Histology)) + 
  geom_boxplot(alpha = .5) +
  coord_flip() +
  theme_bw() +
  theme(legend.position = 'none')

g2 <- ggplot(lung_data_complete,aes(gender, fill = Histology)) + 
  geom_bar(position = 'dodge',alpha = .5) +
  theme_bw() +
  theme(legend.position = 'none')

g3 <- ggplot(lung_data_complete,aes(Overall.Stage, fill = Histology)) + 
  geom_bar(position = 'dodge',alpha = .5) +
  theme_bw() 

g4 <- ggplot(lung_data_complete,aes(Manufacturer, fill = Histology)) + 
  geom_bar(position = 'dodge',alpha = .5) +
  theme_bw() 

(g1 + g2)/(g3 + g4) + plot_layout(guides = "collect") 
ggsave("figures/Fig5.tiff",width = 174, height = 100, device="tiff", dpi=300, units = "mm", scale = 1)
```


I check the relationship between categorical variables with main variables of interest. I use `crosstable` package to ease table construction and automatic test to search for independency.


```{r}
# As we have few observations for N1 group, I will have to join two groups to
# be able to test independence with histology 
table(lung_data_complete$Histology,lung_data_complete$Clinical.N.Stage)
levels(lung_data_complete$Clinical.N.Stage) <- c("0","1_2","1_2","3")


(table7 <- crosstable(lung_data_complete, c(age, gender, clinical.T.Stage,
                                            Clinical.N.Stage,
                                            Overall.Stage, Manufacturer), 
           by = Histology, test = TRUE,
           showNA = 'no') %>% as_flextable() %>% autofit())
table7 %>% save_as_image("tables/table7.png")

(table8 <- crosstable(lung_data_complete, c(age, gender, 
                                            Manufacturer), 
           by = Overall.Stage, test = TRUE,
           showNA = 'no') %>% as_flextable() %>% autofit())
table8 %>% save_as_image("tables/table8.png")
```



In this tables we can easily see how gender and histology, and manufacturer and histology are independent. On the contrary, there seems to be some relationship between histology group and age, as well as between histology and overall stage. In this case it seems specially important to verify the relationship of these variables with any clustering model generated as these could bias interpretation of clustering association to target histology variable.


Though I did not identify here a relationship between histology class and T or N stage, we know this are dependent with overall stage for which we found association to histology class, so we should be careful with this when interpreting model results.


I continue verifying the relationship between ordinal variables using Spearman correlation coeficient 


```{r}
(table9 <- lung_data_complete %>% 
  select(Overall.Stage,clinical.T.Stage) %>% 
  drop_na(Overall.Stage,clinical.T.Stage) %>% 
  table()%>%
  addmargins() %>% 
  kable(full_with = FALSE) %>% kable_classic_2() %>%  
  add_header_above(c("Overall.Stage" = 1, "Clinical.T.Stage" = 5)) )
table9 %>% save_kable("tables/table9.pdf")
cor(as.integer(lung_data_complete$clinical.T.Stage),
    as.integer(lung_data_complete$Overall.Stage),
    method = 'spearman',
    use = 'complete.obs')
```



```{r}
(table10 <- lung_data_complete %>% 
  select(Overall.Stage,Clinical.N.Stage) %>% 
  drop_na(Overall.Stage,Clinical.N.Stage) %>% 
  table()%>%
  addmargins() %>% 
  kable(full_width = FALSE) %>% 
  kable_classic_2() %>%  
  add_header_above(c("Overall.Stage" = 1, "Clinical.N.Stage" = 4))) 
table10 %>% save_kable("tables/table10.pdf")
cor(as.integer(lung_data_complete$Clinical.N.Stage),
        as.integer(lung_data_complete$Overall.Stage),
        method = 'spearman',
        use = 'complete.obs')

```



```{r}
(table11 <- lung_data_complete %>% 
  select(clinical.T.Stage,Clinical.N.Stage) %>% 
  drop_na(clinical.T.Stage,Clinical.N.Stage) %>% 
  table()%>%
  addmargins() %>% 
  kable(full_width = FALSE) %>% 
  kable_classic_2() %>%  
  add_header_above(c("Clinical.T.Stage" = 1, "Clinical.N.Stage" = 4))) 
table11 %>% save_kable("tables/table11.pdf")
cor(as.integer(lung_data_complete$Clinical.N.Stage),
    as.integer(lung_data_complete$clinical.T.Stage),
    method = 'spearman',
    use = 'complete.obs')
```


As expected we see there is some degree of correlation between Overall Stage and T and N clinical categories. On the contrary T and N categories do not show a high degree of correlation.


I check the distribution of different histology classes along study dates to check if there might be any suggestion of potential time batch bias.


```{r}
lung_data_complete$Study.Date <- as.POSIXct(lung_data_complete$Study.Date)
ggplot(lung_data_complete, aes(Study.Date, ..count.., fill = Histology)) + 
    geom_histogram(alpha = .5) +
    theme_bw() + xlab(NULL) +
    scale_x_datetime(breaks = date_breaks("3 months"),
                     labels = date_format("%Y-%b")) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggsave("figures/Fig6.tiff",width = 174, height = 100, device="tiff", dpi=300, units = "mm", scale = 1)

```


Regarding the period of time during which studies were performed, we see all classes seem pretty much represented along the years in favor of avoiding specific technique batch biases. 



Now I want to check if there is a relationship between survival and main categorical classes. To do so I will use `Survival` and `survminer` R packages to construct Kaplan Meyer plots using Survival.time and deadstatus.event variables and compare median survival between different classes.


First I describe general survival probability for the whole group.



```{r}
tiff(filename = "figures/Fig7.1.tiff", width = 300, height = 200, units = "mm", res = 300)
ggsurvplot(survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ 1, data = lung_data_complete), 
           conf.int=TRUE, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           tables.height = 0.2)
fig <- dev.off()
ggsurvplot(survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ 1, data = lung_data_complete), 
           conf.int=TRUE, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           tables.height = 0.2)
survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ 1, data = lung_data_complete)
```


One year probability survival was 0.64 when evaluating the whole group (95% CI: 0.597 - 0.694).


```{r}
tiff(filename = "figures/Fig7.2.tiff", width = 300, height = 200, units = "mm", res = 300)
ggsurvplot(survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ Histology, data = lung_data_complete), 
           conf.int=TRUE, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           tables.height = 0.2)
fig <- dev.off()
ggsurvplot(survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ Histology, data = lung_data_complete), 
           conf.int=TRUE, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           tables.height = 0.2)
```



```{r}
tiff(filename = "figures/Fig8.tiff", width = 300, height = 200, units = "mm", res = 300)
ggsurvplot(survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ Overall.Stage, data = lung_data_complete), 
           conf.int=TRUE, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           tables.height = 0.2)
fig <- dev.off()
ggsurvplot(survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ Overall.Stage, data = lung_data_complete), 
           conf.int=TRUE, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           tables.height = 0.2)
```



```{r}
tiff(filename = "figures/Fig9.tiff", width = 300, height = 200, units = "mm", res = 300)
ggsurvplot(survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ gender, data = lung_data_complete), 
           conf.int=TRUE, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           surv.plot.height = 0.7,
            tables.height = 0.2)
fig <- dev.off()
ggsurvplot(survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ gender, data = lung_data_complete), 
           conf.int=TRUE, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           surv.plot.height = 0.7,
            tables.height = 0.2)
```



```{r}
tiff(filename = "figures/Fig10.tiff", width = 300, height = 200, units = "mm", res = 300)
ggsurvplot(survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ Manufacturer, data = lung_data_complete), 
           conf.int=TRUE, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           surv.plot.height = 0.7,
            tables.height = 0.3)
fig <- dev.off()
ggsurvplot(survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ Manufacturer, data = lung_data_complete), 
           conf.int=TRUE, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           surv.plot.height = 0.7,
            tables.height = 0.3)
sd <- survdiff(Surv(Survival.time, as.numeric(deadstatus.event)) ~ Manufacturer, data = lung_data_complete)
1 - pchisq(sd$chisq, length(sd$n) - 1)
survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ Manufacturer, data = lung_data_complete)
```


While there is no significant relationship between Survival and Histology, Survival and Overall Stage, and Survival and Gender; there is a finding of major importance here regarding observations corresponding to scanners from different Manufacturer. This could add a major bias to the model so we have to exclude any radiomic features related to scanner Manufacturer to make sure to remove any bias from this source.



#### Relationship between radiomic numeric variables 


As there are so many continuous radiomic variables I will just check for the moment their pearson correlation coefficient and represent this with heatmap. After performing variable selection I will further analyze radiomic variables distribution and relationship with other clinical variables.



```{r, fig.width=8, fig.height=8}
radiomic_vars <- lung_data_complete %>% keep(is.numeric) %>%
  select(.,-c(age,Survival.time))
plot_correlation(radiomic_vars, type = "c", theme_config = list("legend.position" = "bottom","axis.text.x" = element_blank(), "axis.text.y" = element_blank()))
ggsave("figures/Fig11.tiff",width = 200, height = 200, device="tiff", dpi=300, units = "mm", scale = 1)
```


Now I will perform a Shapiro Wilk test to formaly evaluate normality for every numeric variable available in current data frame:


```{r}
# I apply shapiro wilk test to every numeric value in the data frame
shap <- lung_data_complete %>% 
  keep(is.numeric) %>% 
  apply(.,2,shapiro.test) 

# I define a vector with a boolean stating if p value is greater than corrected 0.05
shapres <- sapply(shap, function(x) x$p.value > .05/length(shap))
table(shapres)
```


When exploring numerical variable distribution we could already see many variables with an assymetric distribution mostly non-normally distributed variables. We will take this into account when selecting  outlier detection techniques and imputation techniques both for outliers and missing values.




## Missing values and outliers imputation


To perform outlier detection I will use `HDoutliers` package that allows performing multivariate outlier detection for mixed data. To be able to work with this algorithm I need to perform imputation of missing values first so I will use `missForest` package that gives me the possibility to perform missing value imputation, again taking in account the mixed data types we are dealing with.


### Pre-processing step: missing values imputation


I perform missing values imputation first:


```{r}
lung_data.imp <- missForest(lung_data_complete %>% select(.,-Study.Date))

#check imputation error. NRMSE is normalized mean squared error. It is used to represent error derived 
# from imputing continuous values. PFC (proportion of falsely classified) is used to represent error 
# derived from imputing categorical values.
lung_data.imp$OOBerror
#check new values
lung_data.imp$ximp[rownames(lung_data.imp$ximp) %in% rownames(which(is.na(lung_data_complete), arr.ind=TRUE)),] %>% select(age,gender,clinical.T.Stage,Clinical.N.Stage,Clinical.M.Stage,Overall.Stage,deadstatus.event,Manufacturer)

# we can see now M stage is in fact 0 for every entry, so we will remove this column
table(lung_data.imp$ximp$Clinical.M.Stage)

# I remove Clinical M Stage from the dataset and I add Study Date again
lung_data_naimp <- lung_data.imp$ximp %>% select(.,-Clinical.M.Stage) 
```



##### Multivariate outlier detection:


```{r}
# Transforms the data according to the specifications in Wilkinson’s hdoutliers algorithm replaces each categorical variables with a numeric variable corresponding to its first component in multiple correspondence analysis, then maps the data to the unit square

lung_data.trans <- dataTrans(lung_data_naimp)

# Implements the first stage of the hdoutliers Algorithm, in which the data is partitioned according to exemplars and their associated lists of members.

lung_data.mem <- getHDmembers(lung_data.trans)
# An exponential distribution is fitted to the upper tail of the nearest-neighbor distances between
# exemplars (the observations considered representatives of each component of member

lung_data.out <- getHDoutliers(lung_data.trans, lung_data.mem, alpha = 0.05)

# Produces a plot of the data (transformed according to the Wilkinson’s specifications) showing the
# outliers. If the data has more than two dimensions, it is plotted onto the principal components of
# the data that remains after removing outliers.

tiff(filename = "figures/Fig12.tiff", width = 200, height = 150, units = "mm", res = 300)
plotHDoutliers(lung_data_naimp,lung_data.out)
fig <- dev.off()
plotHDoutliers(lung_data_naimp,lung_data.out)

# we identify the specific observations classified as outliers:
rownames(lung_data.trans)[c(lung_data.out)]
```


When taking in account all the categorical and numerical variables available on the data set, excluding dates,  2 particular observations are considered outliers, "LUNG1-027" and "LUNG1-069". Extreme values for a single variable seem to make more sense when they are explained by other variables.


I compare with stray library that has a modified version of hdoutliers, taking only numeric variables, and get the same result:


```{r}
library(stray)
stray_out <- find_HDoutliers(lung_data_naimp %>% keep(is.numeric),alpha = 0.05)
rownames(lung_data.trans)[c(stray_out$outliers)]
```


I remove the outliers detected:


```{r}
# I add study date variable again to the update data set
lung_data_no_na <- lung_data_naimp %>% cbind(Study.Date = lung_data_complete$Study.Date)
lung_data_no_out <- lung_data_no_na[-c(which(rownames(lung_data_no_na) %in% rownames(lung_data.trans)[c(lung_data.out)])),]
dim(lung_data_no_out)
```



## Feature selection for radiomic variables


```{r}
# I build a dataframe just with the radiomic features:
radiomic_vars <- lung_data_no_out %>% keep(is.numeric) %>%
  select(.,-c(age,Survival.time))
```



### Removing non-stable features


```{r}
# I apply shapiro wilk test to every numeric value in the data frame
wilcox <- radiomic_vars %>% apply(.,2,function(x){wilcox.test(x~lung_data_no_out$Manufacturer)}) 

# I define a vector with a boolean stating if p value is greater than corrected 0.05
wilcoxres <- sapply(wilcox, function(x){x$p.value > .05})
table(wilcoxres)
stable_radiomic_vars <- radiomic_vars %>% select(.,-all_of(names(wilcoxres[wilcoxres == TRUE])))
dim(stable_radiomic_vars)
```




### Removing near cero variance features


```{r}
library(caret)
names(stable_radiomic_vars)[nearZeroVar(radiomic_vars)]
```


No near 0 variables





### MRMR


I first use maximum relevance minimum redundance algorithm. As there are so many radiomic features, I want to be sure I preserve most relevant features for the classes of interest while filtering redundant variables. To do so I use `MRMR` function from `praznik` package, and `mRMR.classic` function from `mRMRe` package.


```{r, fig.width=8, fig.height=8}
# I first select MRMR features taking in account histology class:
select1 <- MRMR(stable_radiomic_vars,lung_data_no_out$Histology,k = 20)
names(select1$selection)

# Then I do the same for the survival target interest
df <- as.data.frame(stable_radiomic_vars %>% cbind(surv1 = Surv(lung_data_no_out$Survival.time, lung_data_no_out$deadstatus.event)))
df$original_shape_VoxelVolume <- as.numeric(df$original_shape_VoxelVolume)
dd <- mRMR.data(data = df)
cat('index_surv:' ,grep("surv1", colnames(df)))
select2 <- mRMR.classic(data = dd, target_indices = c(grep("surv1", colnames(df))), feature_count = 20)
selected2_features <- select2@feature_names[solutions(select2)$'533'[,1]]
selected2_features


# I check variables matching for both vectors of selected variables
intersect(names(select1$selection),selected2_features)


# Still keep all the variables selected for at least one class taking in account a variable might be highly related to histology class for example and not to survival and so on
mrmr_radiomics <- stable_radiomic_vars %>% dplyr::select(names(select1$selection),all_of(selected2_features))

plot_correlation(mrmr_radiomics, type = "c", theme_config = list(legend.position = "bottom", axis.text.x = element_text(angle =
    90, size = 9), axis.text.y = element_text(size = 9)))

ggsave("figures/Fig13.tiff",width = 130, height = 130, device="tiff", dpi=300, units = "mm", scale = 1)

dim(mrmr_radiomics)
```


We can see `dim(mrmr_radiomics)[2]` radiomic features were selected taking in account some minimal overlap between both MRMR selections regarding histology or survival.


Then I eliminate still highly redundant variables using `findCorrelation` function from `caret` package.


```{r, fig.width=8, fig.height=8}
# As after MRMR I still have blocks of highly correlated variables I add an additional simple correlation filter to eliminate those still highly correlated:
redundant_vars <- findCorrelation(
  cor(mrmr_radiomics),
  cutoff = 0.95,
  names = TRUE
)
redundant_vars
filtered_radiomics <- mrmr_radiomics %>% dplyr::select(.,-all_of(redundant_vars))
plot_correlation(filtered_radiomics, type = "c")

ggsave("figures/Fig14.tiff",width = 130, height = 130, device="tiff", dpi=300, units = "mm", scale = 1)

dim(filtered_radiomics)

```


We are now left with `dim(filtered_radiomics)[2]` radiomic features.



### Selected radiomic features univariate analysis


```{r}
(table12 <- filtered_radiomics %>% describe() %>% 
    select(described_variables,mean,sd,IQR,skewness,kurtosis) %>% 
  kable(full_with = FALSE) %>% kable_classic_2()) 
table12 %>% save_kable("tables/table12.pdf")
```


In this table we can see summary statistics for selected radiomic features, we can see many of these include negative values, something to take into account when evaluating data transformation.


I further represent univariate distribution by representing data with histograms:


```{r, fig.width=6, fig.height=8}
filtered_radiomics %>% 
  gather() %>% 
  ggplot(aes(value)) +
    facet_wrap(~ key, scales = "free", ncol = 3) +
    geom_histogram() +
    theme(strip.text.x = element_text(size = 50), text = element_text(size=50))+
    theme_minimal()
ggsave("figures/Fig15.tiff",width = 200, height = 300, device="tiff", dpi=300, units = "mm", scale = 1)
```


And I further evaluate normality by generating qqplot for these selected features.


```{r, fig.width=6, fig.height=8}
filtered_radiomics %>% 
  gather() %>% 
  ggplot(aes(sample=value)) +
    facet_wrap(~ key, scales = "free", ncol = 4) +
    stat_qq() +
    theme_minimal() +
    theme(strip.text.x = element_text(size = 5), text = element_text(size=10))
ggsave("figures/Fig16.tiff",width = 200, height = 300, device="tiff", dpi=300, units = "mm", scale = 1)
```


As previously evaluated for the whole dataset with Shapiro Wilk test, we see in both histograms and qqplots that many radiomic variables deviate from normality and have a rather skewed distribution. We should take this into account as data transformation may be needed for optimal performance of different model-based cluster models. 


As we have mainly positive skewed distributions I will apply a log transform after adding a mimimum value to avoid negative and ease optimization of different models.



```{r, fig.width=6, fig.height=8}
min(filtered_radiomics)
log_filtered_radiomics <- filtered_radiomics %>%
  lapply(function(x){log(x+241)}) %>% 
  as.data.frame()

log_filtered_radiomics %>% 
  gather() %>% 
  ggplot(aes(sample=value)) +
    facet_wrap(~ key, scales = "free", ncol = 4) +
    stat_qq() +
    theme_minimal() +
    theme(strip.text.x = element_text(size = 5), text = element_text(size=10))
ggsave("figures/Fig17.tiff",width = 200, height = 300, device="tiff", dpi=300, units = "mm", scale = 1)
```


Now that we have a few selected features, I can deepen radiomic feature description missing on initial global analysis. 


### Selected radiomic features relationship with target variables


We continue with evaluation of selected radiomic feature relationship to pertinent target variables. First I generate boxplots to represent radiomic feature distribution for the different histology classes.


I then evaluate mean and standard deviation of radiomic features within each class and test to verify if any of this relationships might be significant.


```{r}
radiomics_hist <- log_filtered_radiomics %>% cbind(Histology = lung_data_no_out$Histology)
crostab <- crosstable(num_digits = 3,radiomics_hist, c(colnames(radiomics_hist %>% dplyr::select(.,-Histology))), by = Histology, test = TRUE) 

(table13 <- crostab %>% separate(test,
            into = c('pvalue', 
                    'test'),
            sep = "\n") %>% 
            separate(pvalue,
            into = c('string', 
                    'pval'),
            sep = ":",
            convert = TRUE) %>% 
            arrange(pval) %>% 
            filter(variable == 'Mean (std)') %>% 
            dplyr::select(.,-c(string,.id, test)) %>% kable(full_with = FALSE) %>% kable_classic_2()) 
table13 %>% save_kable('tables/table13.pdf')

```


```{r, fig.width=8, fig.height=5}
plot_boxplot(log_filtered_radiomics %>% select(wavelet.LHL_gldm_DependenceVariance,
                                           wavelet.HHH_glcm_ClusterProminence,
                                           wavelet.HHL_gldm_SmallDependenceHighGrayLevelEmphasis,
                                           wavelet.HHH_glcm_Imc1,
                                           wavelet.HHL_glcm_ClusterProminence,
                                           wavelet.HLH_glcm_DifferenceAverage) %>% 
               cbind(Histology = lung_data_no_out$Histology), 
             by = "Histology",
             ncol = 3,
             theme_config = list(strip.text.x = element_text(size = 13), text = element_text(size=15)))
ggsave("figures/Fig18.tiff",width = 100, height = 100, device="tiff", dpi=300, units = "mm", scale = 0.9)
```



```{r}
radiomics_stage <- log_filtered_radiomics %>% cbind(Overall.Stage = lung_data_no_out$Overall.Stage)
crostab <- crosstable(num_digits = 3,radiomics_stage, c(colnames(radiomics_stage %>% dplyr::select(.,-Overall.Stage))), by = Overall.Stage, test = TRUE) 

(table13.1 <- crostab %>% separate(test,
            into = c('pvalue', 
                    'test'),
            sep = "\n") %>% 
            separate(pvalue,
            into = c('string', 
                    'pval'),
            sep = ":",
            convert = TRUE) %>% 
            arrange(pval) %>% 
            filter(variable == 'Mean (std)') %>% 
            dplyr::select(.,-c(string,.id)) %>% kable(full_with = FALSE) %>% kable_classic_2()) 
table13.1 %>% save_kable('tables/table13.1.pdf')

```



```{r, fig.width=8, fig.height=5}
plot_boxplot(log_filtered_radiomics %>% select(wavelet.LHL_glszm_LargeAreaHighGrayLevelEmphasis,
                                           log.sigma.2.0.mm.3D_glrlm_LongRunHighGrayLevelEmphasis,
                                           wavelet.LLH_glrlm_LongRunHighGrayLevelEmphasis,
                                           wavelet.LHL_gldm_SmallDependenceLowGrayLevelEmphasis,
                                           original_shape_VoxelVolume,
                                           wavelet.HHH_glszm_LargeAreaHighGrayLevelEmphasis) %>% 
               cbind(Overall.Stage = lung_data_no_out$Overall.Stage), 
             by = "Overall.Stage",
             ncol = 3,
             theme_config = list(strip.text.x = element_text(size = 13), text = element_text(size=15)))
ggsave("figures/Fig18.1.tiff",width = 100, height = 100, device="tiff", dpi=300, units = "mm", scale = 0.9)
```



Now I will evaluate potential relationship between individual radiomic features and survival. To do so I adjust a cox model for each one.


```{r}
radiomics_surv <- log_filtered_radiomics %>% cbind(Survival.time = lung_data_no_out$Survival.time, deadstatus.event = lung_data_no_out$deadstatus.event) 

surv_formulas <- sapply(colnames(log_filtered_radiomics),function(x) as.formula(paste('Surv(Survival.time,as.numeric(deadstatus.event))~', x)))
surv_models <- lapply(surv_formulas, function(x){coxph(x, data = radiomics_surv)})
surv_rad_vars <- lapply(surv_models,
                       function(x){ 
                          x <- summary(x)
                          p.value<-format(signif(x$wald["pvalue"], digits=2),scientific = FALSE)
                          wald.test<-signif(x$wald["test"], digits=2)
                          beta<-signif(x$coef[1], digits=2);#coeficient beta
                          res<-c(beta, wald.test, p.value)
                          names(res)<-c("beta", "wald.test", 
                                        "p.value")
                          return(res)
                          #return(exp(cbind(coef(x),confint(x))))
                         })
res <- t(as.data.frame(surv_rad_vars, check.names = FALSE))
(table14 <- as.data.frame(res) %>% arrange(p.value) %>% 
  kable(full_with = FALSE) %>% kable_classic_2())
table14 %>% save_kable('tables/table14.pdf')
```


## Clustering


### Construction of imput datasets 


I construct final datasets to use as imput to fit the model-based clustering. I exclude from the datasets the considered 'target variables' including mainly Histology and both components of survival estimates (Survival.time and deadstatus.event). I will also evaluate stage descriptors and scanner model distribution among different clusters once the model if generated. 



```{r}
lung_data_filtered_radiomics <- cbind(lung_data_no_out %>%
                                        dplyr::select(age,
                                                      gender),
                                      log_filtered_radiomics)
(table19 <- describe(lung_data_filtered_radiomics) %>% dplyr::select(described_variables,mean,sd,se_mean,IQR,skewness,kurtosis) %>% 
   kable(full_with = FALSE) %>% kable_classic_2())
  table19 %>% save_kable('tables/table19.pdf')
```


As we can see value ranges differ significantly between numerical variables (radiomics and age included) this could bias the weight of each variable when contributing to the model so it is recomended to have all variables in the same scale. I chose to use min-max scaling. Then categorical variables will be directly treated by VarCellCM. 



```{r}
filtered_cont_scaled <- lung_data_filtered_radiomics %>% keep(is.numeric) %>% 
  lapply(function(x){(x - min(x)) / (max(x) - min(x))}) %>% as.data.frame()

lung_data_filtered_scaled_radiomics <- lung_data_filtered_radiomics %>% 
  keep(is.factor) %>%
  cbind(filtered_cont_scaled)

(table20 <- describe(lung_data_filtered_scaled_radiomics) %>% 
    dplyr::select(described_variables,mean,sd,p00, p50, p100, skewness,kurtosis) %>% kable(full_with = FALSE) %>% kable_classic_2()) 
table20 %>% save_kable('tables/table20.pdf')

```




### Clustering mixed data with VarCellCM 


#### With wrapper variable selection


First I will generate a model based clustering model using the MRMR filtered radiomics dataset with the added clinical variables and scaling done in previous points. I generate the model using `VarSelCluster` function from `VarSelCM` package, using variable selection. I display main discriminative variables given the model adjustment and clusters in 3D scatter plot using principal components as main axes for the representation. I also display the uncertainty probability for each cluster.


```{r, fig.width=8, fig.height=6}
# I adjust VarSelCluster model with variables selection for this first
# approach and using BIC criteria to estimate the optimal number of clusters
set.seed(12345)
res_varsel_select <- VarSelCluster(x = lung_data_filtered_scaled_radiomics,
                          gvals = 2:10, 
                          nbcores = 4, 
                          vbleSelec = TRUE,  
                          crit.varsel = "BIC")

# I check the resulting model summary
summary(res_varsel_select)
res_varsel_select@model@names.relevant
res_varsel_select@model@names.irrelevant

# I check the discriminative power of the variables 
tiff(filename = "figures/Fig22.tiff", width = 250, height = 150, units = "mm", res = 300)
plot(res_varsel_select)
fig <- dev.off()
plot(res_varsel_select)

# I check fit for main discriminative variables
tiff(filename = "figures/Fig22.1.tiff", width = 200, height = 800, units = "mm", res = 300)
plot(res_varsel_select, y="original_shape_VoxelVolume", type="cdf")
plot(res_varsel_select, y="wavelet.HHH_glszm_LargeAreaHighGrayLevelEmphasis", type="cdf")
plot(res_varsel_select, y="wavelet.LHL_glszm_LargeAreaHighGrayLevelEmphasis", type="cdf")
fig <- dev.off()
plot(res_varsel_select, y="original_shape_VoxelVolume", type="cdf")
plot(res_varsel_select, y="wavelet.HHH_glszm_LargeAreaHighGrayLevelEmphasis", type="cdf")
plot(res_varsel_select, y="wavelet.LHL_glszm_LargeAreaHighGrayLevelEmphasis", type="cdf")

# I build q data frame including partitions, variables used in the model and other variables of interest
lung_data_res_varsel <- lung_data_filtered_scaled_radiomics %>% 
                              cbind(lung_data_no_out %>% dplyr::select(Histology,
                                                                Survival.time,
                                                                deadstatus.event,
                                                                Manufacturer,
                                                                Overall.Stage,
                                                                clinical.T.Stage,
                                                                Clinical.N.Stage),
                                    partition = as.factor(res_varsel_select@partitions@zMAP))

# I build a data frame with principal components for radiomic variables to ease visualisation of results
pc_radiomics <- prcomp(lung_data_filtered_scaled_radiomics %>% keep(is.numeric), scale = TRUE)
pc_rad <- pc_radiomics$x[,1:3]
pc_df <- as.data.frame(pc_rad %>% cbind(partition = as.factor(res_varsel_select@partitions@zMAP)))

# I generate a representation of the clusters using the main discriminative variables to define the axes
# (screencapture saved as figure 23)
plot_ly(pc_df, x=~PC1, y=~PC2,
        z=~PC3, color=~as.factor(partition)) %>%
        add_markers(size=1.5)%>%
        layout(
          scene = list(
            xaxis = list(size = 0.5),
            yaxis = list(size = 0.5),
            zaxis = list(size = 0.5)))


# I calculate a distance metric to be able to measure Silhouette Coefficient:
gower_dist <- daisy(lung_data_filtered_scaled_radiomics,
                    metric = "gower")
sil <- silhouette(res_varsel_select@partitions@zMAP, gower_dist)
summary(sil)
tiff(filename = "figures/Fig23.1.tiff", width = 200, height = 150, units = "mm", res = 300)
plot(sil)
fig <- dev.off()
plot(sil)

# I display a summary of the probabilities of missclassification for each cluster
tiff(filename = "figures/Fig24.tiff", width = 200, height = 300, units = "mm", res = 300)
plot(res_varsel_select, type="probs-class")
fig <- dev.off()
plot(res_varsel_select, type="probs-class")
```



```{r}
(crosstab<- crosstable(lung_data_res_varsel %>% dplyr::select(.,-c(deadstatus.event,Survival.time)), showNA = FALSE, 
           by = partition) %>% flextable()%>% autofit())
```



Then I want to evaluate possible relationship between clusters generated and histology class.


```{r}
# I generate a cross table to check distribution of histology classes with partitions
table_hist_clust_res_varsel <- table(lung_data_res_varsel$Histology,lung_data_res_varsel$partition)
addmargins(prop.table(table_hist_clust_res_varsel)) %>% round(3) %>% kable(full_with = FALSE) %>% kable_classic_2()


# I display distribution of histology class within different clusters
ggplot(lung_data_res_varsel,aes(partition, fill = Histology)) + 
  geom_bar(position = 'fill',alpha = .5) +
  coord_flip()+
  theme_bw() 
ggsave("figures/Fig25.tiff",width = 100, height = 50, device="tiff", dpi=300, units = "mm", scale = 1)


# I continue with a correspondence analysis and generate an assymetric representation using 
# columns (clusters) repsented with the principal coordinates and histology classes
# represented with standard coordinates
ca.res_varsel <- ca(table_hist_clust_res_varsel)
tiff(filename = "figures/Fig26.tiff", width = 200, height = 200, units = "mm", res = 300)
plot(ca.res_varsel, map= "colprincipal") 
fig <- dev.off()
plot(ca.res_varsel, map= "colprincipal") 

# From CA analisis I get number of clusters with the greatest inertias to further compare cluster characteristics
clust_top_inertias <- data.frame(clust = ca.res_varsel$colnames, inertia = get_ca_col(ca.res_varsel)$inertia) %>% arrange(desc(inertia)) %>% top_n(2)

# After evaluating main clusters associated with different histology classes we can focus our analysis in 
# describing differences between these clusters:
lung_data_res_varsel_selected <- lung_data_res_varsel %>% filter(partition %in% clust_top_inertias$clust) %>% droplevels()
lung_data_res_varsel_selected_table <- table(lung_data_res_varsel_selected$Histology,lung_data_res_varsel_selected$partition)


# I evaluate agreement using adjusted rand index (ARI) coefficient
cat('ARI (Histology class, Partitions):',ARI(lung_data_res_varsel_selected$Histology,lung_data_res_varsel_selected$partition))


# And I generate a cross table focusing on these clusters
(crosstab1<- crosstable(lung_data_res_varsel_selected %>% select(.,-c(deadstatus.event,Survival.time)), 
           by = partition, test = TRUE)) 

 (table23 <- crosstab1 %>% separate(test,
            into = c('pvalue', 
                    'test'),
            sep = "\n") %>% 
            separate(pvalue,
            into = c('string', 
                    'pval'),
            sep = ":",
            convert = TRUE) %>% 
            arrange(pval) %>% 
            filter(variable != 'Med [IQR]',
                   variable != 'N (NA)',
                   variable != 'Min / Max') %>% 
            dplyr::select(.,-c(string,.id)) %>% kable(full_with = FALSE) %>% kable_classic_2())

 
 table23 %>% save_kable("tables/table23.png")
```



I evaluate relationship with Overall stage variable:


```{r}
# I generate a cross table to check distribution of histology classes with partitions
table_stage_clust_res_varsel <- table(lung_data_res_varsel$Overall.Stage,lung_data_res_varsel$partition)
addmargins(prop.table(table_stage_clust_res_varsel)) %>% round(3) %>% kable(full_with = FALSE) %>% kable_classic_2()

# I display distribution of histology class within different clusters
ggplot(lung_data_res_varsel,aes(partition, fill = Overall.Stage)) + 
  geom_bar(position = 'fill',alpha = .5) +
  coord_flip()+
  theme_bw() 
ggsave("figures/Fig31.1.tiff",width = 100, height = 50, device="tiff", dpi=300, units = "mm", scale = 1)


# I continue with a correspondence analysis and generate an assymetric representation using 
# columns (clusters) repsented with the principal coordinates and histology classes
# represented with standard coordinates
ca.res_varsel_stage <- ca(table_stage_clust_res_varsel)
tiff(filename = "figures/Fig32.1.tiff", width = 200, height = 200, units = "mm", res = 300)
plot(ca.res_varsel_stage, map= "colprincipal") 
fig <- dev.off()
plot(ca.res_varsel_stage, map= "colprincipal") 

# From CA analisis I get number of clusters with the greatest inertias to further compare cluster characteristics
clust_top_inertias_stage <- data.frame(clust = ca.res_varsel_stage$colnames, inertia = get_ca_col(ca.res_varsel_stage)$inertia) %>% arrange(desc(inertia)) %>% top_n(2)

# After evaluating main clusters associated with different histology classes we can focus our analysis in 
# describing differences between these clusters:
lung_data_res_varsel_selected_stage <- lung_data_res_varsel %>% filter(partition %in% clust_top_inertias_stage$clust) %>% droplevels()
lung_data_res_varsel_selected_table_stage <- table(lung_data_res_varsel_selected$Overall.Stage,lung_data_res_varsel_selected$partition)

# I evaluate agreement using adjusted rand index (ARI) coefficient
cat('ARI (Histology class, Partitions):',ARI(lung_data_res_varsel_selected_stage$Overall.Stage,lung_data_res_varsel_selected_stage$partition))


# And I generate a cross table focusing on these clusters
crosstab1.1<- crosstable(lung_data_res_varsel_selected_stage %>% select(.,-c(deadstatus.event,Survival.time)), 
           by = partition, test = TRUE)

 (table23.1 <- crosstab1.1 %>% separate(test,
            into = c('pvalue', 
                    'test'),
            sep = "\n") %>% 
            separate(pvalue,
            into = c('string', 
                    'pval'),
            sep = ":",
            convert = TRUE) %>% 
            arrange(pval) %>% 
            filter(variable != 'Med [IQR]',
                   variable != 'N (NA)',
                   variable != 'Min / Max') %>% 
            dplyr::select(.,-c(string,.id)) %>% kable(full_with = FALSE) %>% kable_classic_2())

 
 table23.1 %>% save_kable("tables/table23.1.png")
```

Finally I want to analyze survival probabilities among different clusters.


```{r,fig.width=8, fig.height=8}
# I generate a specific dataframe including survival, dead status event and partition variables
df_surv_res_varsel <- data.frame(Survival.time = lung_data_no_out$Survival.time, 
                                  deadstatus.event = lung_data_no_out$deadstatus.event,
                         partition = res_varsel_select@partitions@zMAP)

# I create a survival object, and use it as response variable 
# to create Kaplan-Meier survival curves for each cluster
sfit_res_varsel <- survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ partition, 
                            data = df_surv_res_varsel)

# I plot survival curve including confidence intervals for each curve and 
# p value result from log-rank test to evaluate difference in survival between groups
tiff(filename = "figures/Fig27.tiff", width = 300, height = 200, units = "mm", res = 300)
(surv <- ggsurvplot(sfit_res_varsel, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           surv.plot.height = 0.7,
           tables.height = 0.3))
fig <- dev.off()
(surv <- ggsurvplot(sfit_res_varsel, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           surv.plot.height = 0.7,
           tables.height = 0.3))

# I select clusters with minimum and maximum median survival to compare
min_max_surv <- surv_median(sfit_res_varsel) %>% 
  filter(median == min(median) | median == max(median)) %>% 
  select(strata) %>% 
  separate(strata,
            into = c('string', 
                    'partition_num'),
            sep = "=",
            convert = TRUE) 
min_max_surv$partition_num
```



```{r}
# I repeat log-rank test comparing only the two most extreme median survival groups 
surv_pvalue(
  survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ partition, 
          data = df_surv_res_varsel %>% filter(partition %in% min_max_surv$partition_num)),
  method = "survdiff",
  test.for.trend = FALSE,
  combine = FALSE
)


# And describe composition and difference for the clusters with most extreme results on survival analisis
crosstab2<- crosstable(lung_data_res_varsel %>% filter(partition %in% min_max_surv$partition_num) %>% select(.,-c(deadstatus.event,Survival.time)) %>% droplevels(), 
           by = partition, test = TRUE)

 (table24 <- crosstab2 %>% separate(test,
            into = c('pvalue', 
                    'test'),
            sep = "\n") %>% 
            separate(pvalue,
            into = c('string', 
                    'pval'),
            sep = ":",
            convert = TRUE) %>% 
            arrange(pval) %>% 
            filter(variable != 'Med [IQR]',
                   variable != 'N (NA)',
                   variable != 'Min / Max') %>% 
            dplyr::select(.,-c(string,.id)) %>% kable(full_with = FALSE) %>% kable_classic_2())

 
 table24 %>% save_kable("tables/table24.png")
```



#### Without additional variable selection



I generate the model:


```{r, fig.width=8, fig.height=6}
# I adjust VarSelCluster model without variables selection for this second
# approach and using BIC criteria to estimate the optimal number of clusters
set.seed(12345)
res_varsel <- VarSelCluster(x = lung_data_filtered_scaled_radiomics,
                          gvals = 2:10, 
                          nbcores = 4, 
                          vbleSelec = FALSE,  
                          crit.varsel = "BIC")

# I check the resulting model summary
summary(res_varsel)
res_varsel@model@names.relevant
res_varsel@model@names.irrelevant

# I check the discriminative power of the variables 
tiff(filename = "figures/Fig28.tiff", width = 250, height = 150, units = "mm", res = 300)
plot(res_varsel)
fig <- dev.off()
plot(res_varsel)

# I check fit for main discriminative variables
tiff(filename = "figures/Fig28.1.tiff", width = 200, height = 800, units = "mm", res = 300)
plot(res_varsel, y="original_shape_VoxelVolume", type="cdf")
plot(res_varsel, y="wavelet.HHH_glszm_LargeAreaHighGrayLevelEmphasis", type="cdf")
plot(res_varsel, y="wavelet.LHL_glszm_LargeAreaHighGrayLevelEmphasis", type="cdf")
fig <- dev.off()
plot(res_varsel, y="original_shape_VoxelVolume", type="cdf")
plot(res_varsel, y="wavelet.HHH_glszm_LargeAreaHighGrayLevelEmphasis", type="cdf")
plot(res_varsel, y="wavelet.LHL_glszm_LargeAreaHighGrayLevelEmphasis", type="cdf")


# I build q data frame including partitions, variables used in the model and other variables of interest
lung_data_res_varsel <- lung_data_filtered_scaled_radiomics %>% 
                              cbind(lung_data_no_out %>% select(Histology,
                                                                Survival.time,
                                                                deadstatus.event,
                                                                Manufacturer,
                                                                Overall.Stage,
                                                                clinical.T.Stage,
                                                                Clinical.N.Stage),
                                    partition = as.factor(res_varsel@partitions@zMAP))


# I build a data frame with principal components for radiomic variables to ease visualisation of results
pc_radiomics <- prcomp(lung_data_filtered_scaled_radiomics %>% keep(is.numeric), scale = TRUE)
pc_rad <- pc_radiomics$x[,1:3]
pc_df <- as.data.frame(pc_rad %>% cbind(partition = as.factor(res_varsel@partitions@zMAP)))

# I generate a representation of the clusters using the main discriminative variables to define the axes
# (screencapture saved as figure 29)
plot_ly(pc_df, x=~PC1, y=~PC2,
        z=~PC3, color=~as.factor(partition)) %>%
        add_markers(size=1.5)%>%
        layout(
          scene = list(
            xaxis = list(size = 0.5),
            yaxis = list(size = 0.5),
            zaxis = list(size = 0.5)))


# I calculate a distance metric to be able to measure Silhouette Coefficient:
gower_dist <- daisy(lung_data_filtered_scaled_radiomics,
                    metric = "gower")
sil <- silhouette(res_varsel@partitions@zMAP, gower_dist)
tiff(filename = "figures/Fig29.1.tiff", width = 200, height = 150, units = "mm", res = 300)
plot(sil)
fig <- dev.off()
plot(sil)


# I display a summary of the probabilities of missclassification for each cluster
tiff(filename = "figures/Fig30.tiff", width = 400, height = 150, units = "mm", res = 300)
plot(res_varsel, type="probs-class")
fig <- dev.off()
plot(res_varsel, type="probs-class")
```


```{r}
(crosstab<- crosstable(lung_data_res_varsel %>% dplyr::select(.,-c(deadstatus.event,Survival.time)), showNA = FALSE, 
           by = partition) %>% flextable()%>% autofit())


```


Then I want to evaluate possible relationship between clusters generated and histology class.


```{r}
# I generate a cross table to check distribution of histology classes with partitions
table_hist_clust_res_varsel <- table(lung_data_res_varsel$Histology,lung_data_res_varsel$partition)
addmargins(prop.table(table_hist_clust_res_varsel)) %>% round(3) %>% kable(full_with = FALSE) %>% kable_classic_2()


# I display distribution of histology class within different clusters
ggplot(lung_data_res_varsel,aes(partition, fill = Histology)) + 
  geom_bar(position = 'fill',alpha = .5) +
  coord_flip()+
  theme_bw() 
ggsave("figures/Fig31.tiff",width = 100, height = 50, device="tiff", dpi=300, units = "mm", scale = 1)


# I continue with a correspondence analysis and generate an assymetric representation using 
# columns (clusters) repsented with the principal coordinates and histology classes
# represented with standard coordinates
ca.res_varsel <- ca(table_hist_clust_res_varsel)
tiff(filename = "figures/Fig32.tiff", width = 200, height = 200, units = "mm", res = 300)
plot(ca.res_varsel, map= "colprincipal") 
fig <- dev.off()
plot(ca.res_varsel, map= "colprincipal") 

# From CA analisis I get number of clusters with the greatest inertias to further compare cluster characteristics
clust_top_inertias <- data.frame(clust = ca.res_varsel$colnames, inertia = get_ca_col(ca.res_varsel)$inertia) %>% arrange(desc(inertia)) %>% top_n(2)

# After evaluating main clusters associated with different histology classes we can focus our analysis in 
# describing differences between these clusters:
lung_data_res_varsel_selected <- lung_data_res_varsel %>% filter(partition %in% clust_top_inertias$clust) %>% droplevels()
lung_data_res_varsel_selected_table <- table(lung_data_res_varsel_selected$Histology,lung_data_res_varsel_selected$partition)

# I evaluate agreement using adjusted rand index (ARI) coefficient
cat('ARI (Histology class, Partitions):',ARI(lung_data_res_varsel_selected$Histology,lung_data_res_varsel_selected$partition))


# And I generate a cross table focusing on these clusters
crosstab5<- crosstable(lung_data_res_varsel_selected %>% select(.,-c(deadstatus.event,Survival.time)), 
           by = partition, test = TRUE)

 (table25 <- crosstab5 %>% separate(test,
            into = c('pvalue', 
                    'test'),
            sep = "\n") %>% 
            separate(pvalue,
            into = c('string', 
                    'pval'),
            sep = ":",
            convert = TRUE) %>% 
            arrange(pval) %>% 
            filter(variable != 'Med [IQR]',
                   variable != 'N (NA)',
                   variable != 'Min / Max') %>% 
            dplyr::select(.,-c(string,.id)) %>% kable(full_with = FALSE) %>% kable_classic_2())

 
 table25 %>% save_kable("tables/table25.png")
```


```{r}
# I generate a cross table to check distribution of histology classes with partitions
table_stage_clust_res_varsel <- table(lung_data_res_varsel$Overall.Stage,lung_data_res_varsel$partition)
addmargins(prop.table(table_stage_clust_res_varsel)) %>% round(3) %>% kable(full_with = FALSE) %>% kable_classic_2()


# I display distribution of histology class within different clusters
ggplot(lung_data_res_varsel,aes(partition, fill = Overall.Stage)) + 
  geom_bar(position = 'fill',alpha = .5) +
  coord_flip()+
  theme_bw() 
ggsave("figures/Fig31.1.tiff",width = 100, height = 50, device="tiff", dpi=300, units = "mm", scale = 1)


# I continue with a correspondence analysis and generate an assymetric representation using 
# columns (clusters) repsented with the principal coordinates and histology classes
# represented with standard coordinates
ca.res_varsel_stage <- ca(table_stage_clust_res_varsel)
tiff(filename = "figures/Fig32.1.tiff", width = 200, height = 200, units = "mm", res = 300)
plot(ca.res_varsel_stage, map= "colprincipal") 
fig <- dev.off()
plot(ca.res_varsel_stage, map= "colprincipal") 

# From CA analisis I get number of clusters with the greatest inertias to further compare cluster characteristics
clust_top_inertias_stage <- data.frame(clust = ca.res_varsel_stage$colnames, inertia = get_ca_col(ca.res_varsel_stage)$inertia) %>% arrange(desc(inertia)) %>% top_n(2)

# After evaluating main clusters associated with different histology classes we can focus our analysis in 
# describing differences between these clusters:
lung_data_res_varsel_selected_stage <- lung_data_res_varsel %>% filter(partition %in% clust_top_inertias_stage$clust) %>% droplevels()
lung_data_res_varsel_selected_table_stage <- table(lung_data_res_varsel_selected$Overall.Stage,lung_data_res_varsel_selected$partition)

# I evaluate agreement using adjusted rand index (ARI) coefficient
cat('ARI (Histology class, Partitions):',ARI(lung_data_res_varsel_selected_stage$Overall.Stage,lung_data_res_varsel_selected_stage$partition))


# And I generate a cross table focusing on these clusters
crosstab5.1<- crosstable(lung_data_res_varsel_selected_stage %>% select(.,-c(deadstatus.event,Survival.time)), 
           by = partition, test = TRUE)

 (table25.1 <- crosstab5.1 %>% separate(test,
            into = c('pvalue', 
                    'test'),
            sep = "\n") %>% 
            separate(pvalue,
            into = c('string', 
                    'pval'),
            sep = ":",
            convert = TRUE) %>% 
            arrange(pval) %>% 
            filter(variable != 'Med [IQR]',
                   variable != 'N (NA)',
                   variable != 'Min / Max') %>% 
            dplyr::select(.,-c(string,.id)) %>% kable(full_with = FALSE) %>% kable_classic_2())

 
 table25.1 %>% save_kable("tables/table25.1.png")
```



Finally I want to analyze survival probabilities among different clusters.



```{r,fig.width=8, fig.height=8}
# I generate a specific dataframe including survival, dead status event and partition variables
df_surv_res_varsel <- data.frame(Survival.time = lung_data_no_out$Survival.time, 
                                  deadstatus.event = lung_data_no_out$deadstatus.event,
                         partition = res_varsel@partitions@zMAP)

# I create a survival object, and use it as response variable 
# to create Kaplan-Meier survival curves for each cluster
sfit_res_varsel <- survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ partition, 
                            data = df_surv_res_varsel)

# I plot survival curve including confidence intervals for each curve and 
# p value result from log-rank test to evaluate difference in survival between groups
tiff(filename = "figures/Fig33.tiff", width = 300, height = 200, units = "mm", res = 300)
(surv <- ggsurvplot(sfit_res_varsel, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           surv.plot.height = 0.7,
           tables.height = 0.3))
fig <- dev.off()
(surv <- ggsurvplot(sfit_res_varsel, 
           surv.median.line = 'hv',
           pval=TRUE, 
           risk.table='percentage',
           surv.plot.height = 0.7,
           tables.height = 0.3))

min_max_surv <- surv_median(sfit_res_varsel) %>% 
  filter(median == min(median) | median == max(median)) %>% 
  select(strata) %>% 
  separate(strata,
            into = c('string', 
                    'partition_num'),
            sep = "=",
            convert = TRUE) 
min_max_surv$partition_num
```



```{r}
# I repeat log-rank test comparing only the two most extreme median survival groups 
surv_pvalue(
  survfit(Surv(Survival.time, as.numeric(deadstatus.event)) ~ partition, 
          data = df_surv_res_varsel %>% filter(partition %in% min_max_surv$partition_num)),
  method = "survdiff",
  test.for.trend = FALSE,
  combine = FALSE
)


# And describe composition for the clusters with most extreme results on survival analisis
crosstab6<- crosstable(lung_data_res_varsel %>% filter(partition %in% min_max_surv$partition_num) %>% select(.,-c(deadstatus.event,Survival.time)) %>% droplevels(), 
           by = partition, test = TRUE) 

 (table26 <- crosstab6 %>% separate(test,
            into = c('pvalue', 
                    'test'),
            sep = "\n") %>% 
            separate(pvalue,
            into = c('string', 
                    'pval'),
            sep = ":",
            convert = TRUE) %>% 
            arrange(pval) %>% 
            filter(variable != 'Med [IQR]',
                   variable != 'N (NA)',
                   variable != 'Min / Max') %>% 
            dplyr::select(.,-c(string,.id)) %>% kable(full_with = FALSE) %>% kable_classic_2())

 
 table26 %>% save_kable("tables/table26.png")
```

            
```{r}
cat('ARI (Histology class, Partitions):',ARI(res_varsel@partitions@zMAP,res_varsel_select@partitions@zMAP))
res_varsel_select
```



### References


* Aerts, H. J. W. L., Wee, L., Rios Velazquez, E., Leijenaar, R. T. H., Parmar, C., Grossmann, P., Carvalho, S., Bussink, J., Monshouwer, R., Haibe-Kains, B., Rietveld, D., Hoebers, F., Rietbergen, M. M., Leemans, C. R., Dekker, A., Quackenbush, J., Gillies, R. J., Lambin, P. (2019). Data From NSCLC-Radiomics [Data set]. The Cancer Imaging Archive. https://doi.org/10.7937/K9/TCIA.2015.PF0M9REI
* Aerts, H. J. W. L., Velazquez, E. R., Leijenaar, R. T. H., Parmar, C., Grossmann, P., Carvalho, S., Bussink, J., Monshouwer, R., Haibe-Kains, B., Rietveld, D., Hoebers, F., Rietbergen, M. M., Leemans, C. R., Dekker, A., Quackenbush, J., Gillies, R. J., Lambin, P. (2014, June 3). Decoding tumour phenotype by noninvasive imaging using a quantitative radiomics approach. Nature Communications. Nature Publishing Group. https://doi.org/10.1038/ncomms5006
* Clark K, Vendt B, Smith K, Freymann J, Kirby J, Koppel P, Moore S, Phillips S, Maffitt D, Pringle M, Tarbox L, Prior F. The Cancer Imaging Archive (TCIA): Maintaining and Operating a Public Information Repository, Journal of Digital Imaging, Volume 26, Number 6, December, 2013, pp 1045-1057. https://doi.org/10.1007/s10278-013-9622-7
* R Core Team. (2020). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/
* Wickham et al., (2019). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686, https://doi.org/10.21105/joss.01686
* Garrett Grolemund, Hadley Wickham (2011). Dates and Times Made Easy with lubridate. Journal of Statistical Software, 40(3), 1-25. URL https://www.jstatsoft.org/v40/i03/.
* Nicholas Tierney, Di Cook, Miles McBain and Colin Fay (2021). naniar: Data Structures, Summaries, and Visualisations for Missing Data. R package version 0.6.1. https://CRAN.R-project.org/package=naniar
* Boxuan Cui (2020). DataExplorer: Automate Data Exploration and Treatment. R package version 0.8.2. https://CRAN.R-project.org/package=DataExplorer
* C. Sievert. Interactive Web-Based Data Visualization with R, plotly, and shiny. Chapman and Hall/CRC Florida, 2020.
* Thomas Lin Pedersen (2020). patchwork: The Composer of Plots. R package version 1.1.1. https://CRAN.R-project.org/package=patchwork
* Elin Waring, Michael Quinn, Amelia McNamara, Eduardo Arino de la Rubia, Hao Zhu and Shannon Ellis (2022). skimr: Compact and Flexible Summaries of Data. R package version 2.1.4. https://CRAN.R-project.org/package=skimr
* Choonghyun Ryu (2022). dlookr: Tools for Data Diagnosis, Exploration, Transformation. R package version 0.5.6. https://CRAN.R-project.org/package=dlookr
* Dan Chaltiel (2022). crosstable: Crosstables for Descriptive Analyses. R package version 0.4.1. https://CRAN.R-project.org/package=crosstable
* Hao Zhu (2021). kableExtra: Construct Complex Table with 'kable' and Pipe Syntax. R package version 1.3.4. https://CRAN.R-project.org/package=kableExtra
* David Gohel (2022). flextable: Functions for Tabular Reporting. R package version 0.7.0. https://CRAN.R-project.org/package=flextable
* Daniel J. Stekhoven (2022). missForest: Nonparametric Missing Value Imputation using Random Forest.R package version 1.5.
* Stekhoven, D.J. and Buehlmann, P. (2012), 'MissForest - nonparametric missing value imputation for mixed-type data', Bioinformatics, 28(1) 2012, 112-118, doi: 10.1093/bioinformatics/btr597
* Chris Fraley (2022). HDoutliers: Leland Wilkinson's Algorithm for Detecting Multidimensional Outliers. R package version 1.0.4. https://CRAN.R-project.org/package=HDoutliers
* Wilkinson, L. (2017). Visualizing big data outliers through distributed aggregation. IEEE transactions on visualization and computer graphics, 24(1), 256-266.
* Max Kuhn (2022). caret: Classification and Regression Training. R package version 6.0-92. https://CRAN.R-project.org/package=caret
* Peng, H., Long, F., \& Ding, C. (2005). Feature selection based on mutual information criteria of max-dependency, max-relevance, and min-redundancy. IEEE Transactions on pattern analysis and machine intelligence, 27(8), 1226-1238.
*  Miron B. Kursa (2021). Praznik: High performance information-based feature selection. SoftwareX, 16, 100819. URL https://doi.org/10.1016/j.softx.2021.100819
* N De Jay, S Papillon-Cavanagh, C Olsen, G Bontempi and B Haibe-Kains mRMRe: an R package for parallelized mRMR ensemble feature selection Submitted (2012).
* Marbac, M., \& Sedki, M. (2019). VarSelLCM: an R/C++ package for variable selection in model-based clustering of mixed-data with missing values. Bioinformatics, 35(7), 1255-1257.
* Marbac, M. and Patin, E. and Sedki, M. (2020). Variable selection for mixed data clustering: Application in human population genomics. Journal of Classification. 37:124–142. https://doi.org/10.1007/s00357-018-9301-y
* Maechler M, Rousseeuw P, Struyf A, Hubert M, Hornik K (2022). cluster: Cluster Analysis Basics and Extensions. R package version 2.1.3 — For new features, see the 'Changelog' file (in the package source), https://CRAN.R-project.org/package=cluster
* Nenadic, O., Greenacre, M. (2007) Correspondence Analysis in R, with two- and three-dimensional graphics: The ca package. Journal of Statistical Software 20(3):1-13.
* Alboukadel Kassambara and Fabian Mundt (2020). factoextra: Extract and Visualize the Results of Multivariate Data Analyses. R package version 1.0.7. https://CRAN.R-project.org/package=factoextra
* Therneau T (2022). A Package for Survival Analysis in R. R package version 3.3-1, https://CRAN.R-project.org/package=survival.
* Alboukadel Kassambara, Marcin Kosinski and Przemyslaw Biecek (2021). survminer: Drawing Survival Curves using 'ggplot2'. R package version 0.4.9. https://CRAN.R-project.org/package=survminer
